\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{changepage}
\usepackage{pythonhighlight}
\usepackage{stix}
\usepackage{tikz}
\usetikzlibrary{matrix, backgrounds}
\usepackage{titling}
\usepackage{xcolor}

\title{\textit{Data Structures \& Algorithms} Cheat Sheet}
\setlength{\droptitle}{-20ex}
\author{Thomas Monson}
\renewcommand\maketitlehookb{\vspace{-3ex}}
\date{}
\renewcommand\maketitlehookd{\vspace{-2ex}}

\setlength\parindent{0pt}

\begin{document}
\maketitle

\section*{Essential Patterns}
\hrule\vspace{5ex}

\subsection*{Dynamic Programming}

\begin{adjustwidth}{2em}{0pt}
Optimal substructure $\implies$ divide and conquer \medskip\\
Optimal substructure + greedy choice $\implies$ greedy \medskip\\
Optimal substructure + overlapping subproblems \\
\-\hspace{1em}$\implies$ dynamic programming \\

\textbf{Would it be helpful to rephrase a problem in order to more easily define its subproblems?} \\

\-\hspace{1em}\fbox{\begin{minipage}{28em}
  Given an integer array, return the length of the longest strictly increasing subsequence (LIS). \smallskip\\
  \-\hspace{1em}$\equiv$\hspace{0.5em} Return the length of the LIS of an array \texttt{a} of length $n$. \\
  \-\hspace{1em}$\equiv$\hspace{0.5em} Return the length of the LIS of \texttt{a[0:n]}. \bigskip\\
  The LIS of \texttt{a} must have some first element. If this is the $i$th element, then the LIS of \texttt{a} is equal to the LIS of \texttt{a[i:]}, where \texttt{a[i]} is the first element of the sequence. \medskip\\
  Let \texttt{dp[i]} be the length of the LIS of \texttt{a[i:]}, where \texttt{a[i]} is the first element of the sequence. Return \texttt{max(dp)}.
\end{minipage}} \bigskip

\item \texttt{@functools.lru\_cache}
\end{adjustwidth}

\subsection*{Arrays}

\begin{adjustwidth}{2em}{0pt}
\textbf{Would it help to know the sum of elements for any subarray in O(n) time?} \\

Computing the \textbf{prefix sum} of an array \texttt{a} will give you the sum of elements for subarrays \texttt{[a[:i] for i in range(1, len(a))]}. By subtracting elements of the prefix sum from each other, you can get the sum of elements for any subarray. That is, \texttt{sum(a[x:y]) = sum(a[:y]) - sum(a[:x])} for $x < y$.

\subsection*{Searching}

\begin{adjustwidth}{2em}{0pt}
Here's some code for a binary search:
\begin{python}
def binary_search(nums: list[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1
        elif nums[mid] > target:
            right = mid - 1
        else:
            return mid
    return -1
\end{python}

\texttt{bisect} (binary search)
\end{adjustwidth}

\subsection*{Sorting}

\begin{adjustwidth}{2em}{0pt}
\textbf{Do you need to sort items according to a custom scheme?}
\begin{itemize}
  \item \texttt{functools.cmp\_to\_key} 
  \item Create class and define dunder methods \texttt{\_\_lt\_\_}, \texttt{\_\_gt\_\_}, \texttt{\_\_le\_\_}, \texttt{\_\_ge\_\_}, \texttt{\_\_eq\_\_}, \texttt{\_\_ne\_\_}
\end{itemize}
\end{adjustwidth}

\subsection*{Other Stuff}

\begin{itemize}
  \item Helper method recursion (parameter or nonlocal)
  \item Kadane's algorithm (maximum subarray)
  \item Knapsack problem (combinatorial optimization)
  \item Sweep line algorithm (convex hull)
  \item Backtracking (DFS)
  \item Sliding window
  \item Topological sorting (scheduling, Kahn's algorithm)
  \item LRU Cache (hash map + DLL, OrderedDict)
  \item Monotonic stack
  \item Union-find
\end{itemize}

\section*{Useful Python Constructs}
\hrule\vspace{5ex}

\begin{itemize}
  \item Would it be helpful to count items in a collection? \\
    \-\hspace{1em} $\implies$ \texttt{Counter} creates a dictionary of the form \texttt{\{element: count\}}
  \item \texttt{defaultdict}
  \item \texttt{itertools.combinations}, \texttt{itertools.permutations}
  \item \texttt{re} (regex)
  \item \texttt{ord(char)} (ASCII)
  \item \texttt{enumerate} $\rightarrow$ \texttt{count, value}
\end{itemize}

\section*{Other}
\hrule\vspace{5ex}

\begin{itemize}
  \item The fastest way to reverse a list is to use the ``Martian smiley" \texttt{[::-1]}
  \item DFS $\rightarrow$ stack (recursion) $\rightarrow$ LIFO
  \item BFS $\rightarrow$ queue (iteration) $\rightarrow$ FIFO
  \item Online tests: have a Python scratchpad open, spam the ``Run Tests" button (EAFP > LBYL)
  \item Number of subarrays of array of size $n$: $\frac{n(n+1)}{2}$
  \item Python is pass-by-assignment
  \begin{itemize}
    \item Immutable objects are pass-by-value
    \item Mutable objects are pass-by-reference
    \item You can rebind the variable in the inner scope, but the outer scope will remain unchanged
  \end{itemize}
\end{itemize}

\section*{Potentially Useful Algorithms}
\hrule\vspace{5ex}

\begin{itemize}
  \item Rabin-Karp (string-searching, uses a rolling hash to make approximate comparisons between substring hash and target hash, makes exact comparison if hashes match)
  \item Kruskal's algorithm and Prim's algorithm (minimum spanning tree)
\end{itemize}
\end{document}

% \begin{tikzpicture}
% \matrix (m) [matrix of nodes,
%              nodes={draw, minimum size=8mm, anchor=center},
%              nodes in empty cells, minimum height=1cm,
%              row 1/.style={nodes={draw=none}},]
% {
%   \texttt{0} & \texttt{1} & \texttt{2} & \texttt{3} & \texttt{4} & \texttt{5} & \texttt{6} & \texttt{7} & \texttt{8} \\
%   2 & 4 & 4 & 5 &   &   &   &  &\\
% };
% \draw[semithick] (-3.66, -0.9) -- ++(0, -0.1) -- ++(0.81, 0) -- ++(0, 0.1);
% \draw[semithick] (-3.66, -1.1) -- ++(0, -0.1) -- ++(1.62, 0) -- ++(0, 0.1);
% \draw[semithick] (-3.66, -1.3) -- ++(0, -0.1) -- ++(2.43, 0) -- ++(0, 0.1);
% \draw[semithick] (-3.66, -1.5) -- ++(0, -0.1) -- ++(3.24, 0) -- ++(0, 0.1);
% \end{tikzpicture}

